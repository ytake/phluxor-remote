<?php

declare(strict_types=1);

# Generated by the protocol buffer compiler (for Phluxor). DO NOT EDIT!
# source: websocket_remote.proto

namespace Phluxor\Remote\WebSocket\ProtoBuf;

use BadMethodCallException;
use Exception;
use Google\Protobuf\Internal\RepeatedField;
use Phluxor\ActorSystem\Message\DetectSystemMessage;
use Phluxor\ActorSystem\Message\MessageHeader;
use Phluxor\ActorSystem\ProtoBuf\Pid;
use Phluxor\ActorSystem\ProtoBuf\Terminated;
use Phluxor\ActorSystem\Ref;
use Phluxor\Remote\Message\RemoteTerminate;
use Phluxor\Remote\ProtoBuf\ConnectRequest;
use Phluxor\Remote\ProtoBuf\ConnectResponse;
use Phluxor\Remote\ProtoBuf\DisconnectRequest;
use Phluxor\Remote\ProtoBuf\GetProcessDiagnosticsRequest;
use Phluxor\Remote\ProtoBuf\GetProcessDiagnosticsResponse;
use Phluxor\Remote\ProtoBuf\ListProcessesRequest;
use Phluxor\Remote\ProtoBuf\ListProcessesResponse;
use Phluxor\Remote\ProtoBuf\MessageBatch;
use Phluxor\Remote\ProtoBuf\MessageEnvelope;
use Phluxor\Remote\ProtoBuf\RemoteMessage;
use Phluxor\Remote\ProtoBuf\ServerConnection;
use Phluxor\Remote\Remote;
use Phluxor\Remote\Serializer\RootSerializedInterface;
use Phluxor\Remote\Serializer\SerializerManager;
use Phluxor\WebSocket;
use Phluxor\WebSocket\Constant;
use Phluxor\WebSocket\ContextInterface;
use Phluxor\WebSocket\Message;
use Phluxor\WebSocket\Server;
use Swoole\Coroutine\Channel;

class RemotingService implements RemotingInterface
{
    private Channel $suspend;

    public function __construct(
        private Remote $remote,
        private SerializerManager $serializerManager
    ) {
        $this->suspend = new Channel(1);
    }

    /**
     * @param WebSocket\ContextInterface $ctx
     * @param WebSocket\Stream $stream
     * @return void
     *
     * @throws WebSocket\Exception\InvokeException
     * @throws \Swoole\Exception|Exception
     */
    public function Receive( // @phpcs:ignore
        WebSocket\ContextInterface $ctx,
        WebSocket\Stream $stream
    ): void {
        $disconnectChannel = new \Swoole\Coroutine\Channel(1);
        $edpm = $this->remote->getEndpointManager();
        if ($edpm->getEndpointReaderConnections() === null) {
            throw new \RuntimeException('EndpointReaderConnections not found');
        }
        if (!isset($ctx[Constant::SERVER_WORKER_CONTEXT])) {
            throw new \RuntimeException('Server not found');
        }
        /** @var Server $writer */
        $writer = $ctx[Constant::SERVER_WORKER_CONTEXT]->getValue(Server::class);
        $edpm->getEndpointReaderConnections()->set(spl_object_id($writer), $disconnectChannel);
        $rm = new RemoteMessage();
        $rm->setDisconnectRequest(new DisconnectRequest());
        try {
            \Swoole\Coroutine\go(function () use ($disconnectChannel, $writer, $edpm, $ctx, $rm) {
                if ($disconnectChannel->pop()) {
                    $this->remote->logger()->debug("RemotingService is telling to remote that it's leaving");
                    $writer->push(new Message($ctx, $rm));
                } else {
                    $edpm->getEndpointReaderConnections()->delete(spl_object_id($writer));
                    $this->remote->logger()->debug("RemotingService removed active endpoint from endpointManager");
                }
            });
            while (true) {
                if ($this->suspend->pop(0.01)) {
                    $stream->close();
                    break;
                }
                $message = $stream->recv();
                if (!$message instanceof RemoteMessage) {
                    continue;
                }
                if ($message->getMessageType() === '') {
                    continue;
                }
                switch (true) {
                    case $message->hasConnectRequest():
                        $this->remote->logger()->debug(
                            "RemotingService received connect request",
                            ['message' => $message]
                        );
                        if ($message->getConnectRequest() === null) {
                            $this->remote->logger()->error("RemotingService received null message connect request");
                            break;
                        }
                        $err = $this->onConnectRequest($ctx, $writer, $message->getConnectRequest());
                        if (!$err) {
                            $this->remote->logger()->error("RemotingService failed to handle connect request");
                            break;
                        }
                        break;
                    case $message->hasMessageBatch():
                        if ($message->getMessageBatch() === null) {
                            $this->remote->logger()->error("RemotingService received null message batch");
                            break;
                        }
                        $err = $this->onMessageBatch($message->getMessageBatch());
                        if (!$err) {
                            $this->remote->logger()->error(
                                "RemotingService failed to handle message batch"
                            );
                            break;
                        }
                        break;
                    default:
                        $this->remote->logger()->notice("RemotingService received unknown message type");
                }
                \Swoole\Coroutine::sleep(0.1);
            }
        } catch (WebSocket\Exception\ConnectionClosedException $e) {
            $this->remote->logger()->info('RemotingService WebSocket connection closed');
        } finally {
            $disconnectChannel->close();
            $this->suspend->close();
        }
    }

    /**
     * @throws Exception
     */
    private function onConnectRequest(
        ContextInterface $ctx,
        Server $writer,
        ConnectRequest $request
    ): bool {
        switch (true) {
            case !is_null($request->getServerConnection()):
                $sc = $request->getServerConnection();
                $this->onServerConnection($ctx, $writer, $sc);
                return true;
            case !is_null($request->getClientConnection()):
                $this->remote->logger()->error("ClientConnection not implemented");
                return false;
            default:
                $this->remote->logger()->error("RemotingService received unknown connection type");
                return false;
        }
    }

    public function onMessageBatch(MessageBatch $messageBatch): bool
    {
        /** @var ?Pid $sender */
        $sender = null;
        /** @var ?Pid $target */
        $target = null;
        /** @var MessageEnvelope $envelope */
        foreach ($messageBatch->getEnvelopes() as $envelope) {
            $data = $envelope->getMessageData();
            $sender = $this->deserializeSender(
                $sender,
                $envelope->getSender(),
                $envelope->getSenderRequestId(),
                $messageBatch->getSenders()
            );
            $target = $this->deserializeTarget(
                $target,
                $envelope->getTarget(),
                $envelope->getTargetRequestId(),
                $messageBatch->getTargets()
            );
            if ($target === null) {
                $this->remote->logger()->error(
                    "RemotingService received message with unknown target.",
                    [
                        'target' => $envelope->getTarget(),
                        'targetRequestId' => $envelope->getTargetRequestId()
                    ]
                );
                return false;
            }
            $deserialized = $this->serializerManager->deserialize(
                $data,
                $messageBatch->getTypeNames()[$envelope->getTypeId()], // @phpstan-ignore-line
                $envelope->getSerializerId()
            );
            if ($deserialized->exception != null) {
                $this->remote->logger()->error(
                    "RemotingService failed to deserialize message",
                    ['error' => $deserialized->exception]
                );
                return false;
            }
            $message = $deserialized->message;
            if ($message instanceof RootSerializedInterface) {
                $result = $message->deserialize();
                if ($result->exception != null) {
                    $this->remote->logger()->error(
                        "RemotingService failed to deserialize message",
                        ['error' => $result->exception]
                    );
                    return false;
                }
            }
            switch (true) {
                case $message instanceof Terminated:
                    $this->remote->getEndpointManager()->remoteTerminate(
                        new RemoteTerminate($message->getWho(), $target) // @phpstan-ignore-line
                    );
                    break;
                case $this->isSystemMessage($message):
                    $ref = $this->remote->actorSystem->getProcessRegistry()->getLocal($target->getId());
                    if ($ref->isProcess()) {
                        $ref->getProcess()->sendSystemMessage(new Ref($target), $message);
                    }
                    break;
                default:
                    /** @var array<string, string> $header */
                    $header = [];
                    if ($sender === null) {
                        if ($envelope->getMessageHeader() === null) {
                            $this->remote->actorSystem->root()->send(new Ref($target), $message);
                            break;
                        }
                    }
                    if ($envelope->getMessageHeader() != null) {
                        $header = $envelope->getMessageHeader()->getHeaderData();
                    }
                    $localEnvelope = new \Phluxor\ActorSystem\Message\MessageEnvelope(
                        new MessageHeader($header), // @phpstan-ignore-line
                        $message,
                        new Ref($sender),
                    );
                    $this->remote->actorSystem->root()->send(new Ref($target), $localEnvelope);
                    break;
            }
        }
        return true;
    }

    /**
     * @param WebSocket\ContextInterface $ctx
     * @param ListProcessesRequest $request
     * @return ListProcessesResponse
     *
     * @throws WebSocket\Exception\InvokeException
     */
    public function ListProcesses( // @phpcs:ignore
        WebSocket\ContextInterface $ctx,
        ListProcessesRequest $request
    ): ListProcessesResponse {
        throw new BadMethodCallException('Method not implemented');
    }

    /**
     * @param WebSocket\ContextInterface $ctx
     * @param GetProcessDiagnosticsRequest $request
     * @return GetProcessDiagnosticsResponse
     *
     * @throws WebSocket\Exception\InvokeException
     */
    public function GetProcessDiagnostics( // @phpcs:ignore
        WebSocket\ContextInterface $ctx,
        GetProcessDiagnosticsRequest $request
    ): GetProcessDiagnosticsResponse {
        // your code
        throw new BadMethodCallException('Method not implemented');
    }

    /**
     * @param Pid|null $pid
     * @param int $index
     * @param int $requestId
     * @param RepeatedField $arr
     * @return Pid|null
     */
    private function deserializeSender(
        ?Pid $pid,
        int $index,
        int $requestId,
        RepeatedField $arr
    ): ?Pid {
        if ($index === 0) {
            $pid = null;
        } else {
            if (!isset($arr[$index - 1])) {
                return null;
            }
            /** @var Pid $pid */
            $pid = $arr[$index - 1];
            if ($requestId > 0) {
                if ($pid != null) {
                    $pid = $this->cloneRef($pid);
                    $pid->setRequestId($requestId);
                }
            }
        }
        return $pid;
    }

    /**
     * @param Pid|null $pid
     * @param int $index
     * @param int $requestId
     * @param RepeatedField $arr
     * @return Pid|null
     */
    private function deserializeTarget(
        ?Pid $pid,
        int $index,
        int $requestId,
        RepeatedField $arr
    ): ?Pid {
        if (!isset($arr[$index])) {
            return null;
        }
        /** @var Pid $pid */
        $pid = $arr[$index];
        // if request id is used.
        // make sure to clone the Ref first, so we don't corrupt the lookup
        if ($requestId > 0) {
            if ($pid != null) {
                $pid = $this->cloneRef($pid);
                $pid->setRequestId($requestId);
            }
        }
        return $pid;
    }

    /**
     * @throws Exception
     */
    private function onServerConnection(
        ContextInterface $ctx,
        Server $writer,
        ServerConnection $sc
    ): void {
        if ($this->remote->getBlockList()->isBlocked($sc->getSystemId())) {
            $this->remote->logger()->debug("RemotingService is blocked.");
            $rm = new RemoteMessage();
            $rm->setConnectResponse(new ConnectResponse([
                'member_id' => $this->remote->actorSystem->getId(),
                'blocked' => true
            ]));
            $writer->push(new Message($ctx, $rm));
            return;
        }
        $rm = new RemoteMessage();
        $rm->setConnectResponse(new ConnectResponse([
            'member_id' => $this->remote->actorSystem->getId(),
            'blocked' => false
        ]));
        $writer->push(new Message($ctx, $rm));
    }

    private function cloneRef(Pid $ref): Pid
    {
        return new Pid([
            'address' => $ref->getAddress(),
            'id' => $ref->getId(),
            'request_id' => $ref->getRequestId()
        ]);
    }

    public function suspend(bool $to): void
    {
        $this->suspend->push($to);
    }

    private function isSystemMessage(mixed $msg): bool
    {
        $expect = new DetectSystemMessage($msg);
        if ($expect->isMatch()) {
            return true;
        }
        return false;
    }
}
